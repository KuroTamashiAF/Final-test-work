**Описание решения (ветка master)**

В файле **_al.drawio_** отрисована блок-схема основного алгоритма, цифрами отмечены шаги выполнения основного алгоритма.

**Шаги:**

0. Начало выполнения основного алгоритма, 
который отбирает все елементы массива длина которых меньше или равна 3 символам
и перезаписывает их в новый массив. При этом изначальный массив который ввел пользователь остаеться неизменным.

1. Исходные данные которые были полученны **_Основным Алгоритмом(далее ОА)_** на входе, где 
**сountElementNewArray** - количество элементов нового массива, если точнее длина результирующего массива, 
i(index) - счетчик для цикла **for**, по простому - **индекс**.
 **ArrayInput** - Заполненный пользователем массив, для ОА входной массив.
 **Lenght(ArrayInput)** - длина(размер) входного массива, вызванная при помощи **ArrayInput.Lenght**, которая нам необходима для цикла **for**.

2. Цикл **for**, пробегаемся по всей длине массива равной **Lenght(ArrayInput)**, цикл выполняется до тех пор пока 
**i(index)** меньше длины массива **Lenght(ArrayInput)**.

3. Условие **if** в данном случае на вход в ОА поступает массив строк(**типа string**), а значит длина есть как у самого массива **ArrayInput**, так и у каждого элемента массива **ArrayInput**, в процесе выполнения цикла **for** шаг:2, выбираются только те элементы массива **ArrayInput**, длина которых меньше или равна 3 символам.

4. Если условие шаг:3 выполняеться, т.е если в ответ на условие получаем ответ _YES_, то переменная **CountElementNewArray** увеличивается на 1. 

5. Не важно выполнился ли шаг:3 условие или же нет, в любом из этих случаев увеличиваем **i(index)** на 1, и возвращаемся к шагу:2 и проверяем меньше ли 
**i(index)**, чем длина **Lenght(ArrayInput)** массива **ArrayInput**, если **i(index)** меньше чем, длина **Lenght(ArrayInput)** массива **ArrayInput**, то идем на еще 1 круг, если же **i(index)** больше чем, длина **Lenght(ArrayInput)** массива **ArrayInput**, то переходим к шагу:6.

6. Создаем новый массив **ResultArray** результирующий массив, длина которого **Lenght(ResultArray)** равна **countElementNewArray** посчитаному нами ранее количеству элементов нового массива. 

7. (шаг 7 не обязательный, а имеет характер напоминательный, с вводом новой переменной).
У нас имееться входной массив **ArrayInput**, длина которого равна **Lenght(ArrayInput)**, так же в шаге 6 мы создали, результирующий массив **ResultArray**, длина которого равна **countElementNewArray**, вводим новые переменные, а имеено:

    **7.1.** Создаем новый индекс **j(index)** как счетчик для цикла **for**, цикл выполняется до тех пор пока 
    **j(index)** меньше длины массива **Lenght(ArrayInput)**.

    **7.2.** Создаем новый индекс **k(index)**
    как индекс массива **ResultArray** и счетчик одновременно т.к длина массива **ResultArray**, не может быть больше длины массива **ArrayInput**
    в противном случае компилятор выдаст ошибку что мы вышли за граница массива **ResultArray**, и программа не будет работать. 

8. Цикл **for**, пробегаемся по всей длине массива равной **Lenght(ArrayInput)**, цикл выполняется до тех пор пока 
**j(index)** меньше длины массива **Lenght(ArrayInput)**.

9. Условие **if** в процесе выполнения цикла **for** шаг:8, выбираются только те элементы массива **ArrayInput**, длина которых меньше или равна 3 символам.

10. Поскольку мы уже знаем сколько элементов бужет в массиве **ResultArray**, мы переписывем элементы **ArrayInput**, которые удовлетворяют шагу:9, в массив **ResultArray**, и после каждой записи увеличиваем k(index) на 1. 

11. Не важно выполнился ли шаг:9 условие или же нет, в любом из этих случаев увеличиваем **j(index)** на 1, и возвращаемся к шагу:8 и проверяем меньше ли 
**j(index)**, чем длина **Lenght(ArrayInput)** массива **ArrayInput**, если **j(index)** меньше чем, длина **Lenght(ArrayInput)** массива **ArrayInput**, то идем на еще 1 круг, если же **j(index)** больше чем, длина **Lenght(ArrayInput)** массива **ArrayInput**, то переходим к шагу:12.

12. Вывод **ResultArray** результирующего массива, в основную программу.(при желинии его можно вывести и в файл и куда либо еще).

13. Окончание выполнения основного алгоритма.

